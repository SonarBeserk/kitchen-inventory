# Design Notes

Notes about design choices and potential issues that might show up later.

# Table of Contents

> Table of contents generated by [Markdown All in One VSCode extension](https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one)

- [Design Notes](#design-notes)
- [Table of Contents](#table-of-contents)
  - [What is the stack?](#what-is-the-stack)
  - [Why C#?](#why-c)
  - [Why Htmx?](#why-htmx)
  - [Why SqlLite?](#why-sqllite)

## What is the stack?

> As described by Wikipedia: "In computing, a solution stack or software stack is a set of software subsystems or components needed to create a complete platform such that no additional software is needed to support applications.[1] Applications are said to "run on" or "run on top of" the resulting platform."

- .Net 8.0 Web Application written in C#
- Htmx based frontend
- Sqlite data storage

## Why C#?

A good question is why use C# for a project like this. The application at the time of writing is an html frontend with a bit of Htmx markup and a set of apis. Nothing about this stack inherently requires C#, but the tooling provided makes the development experience much nicer. An often used alternative would be to simply write up a [Golang](https://go.dev/) server that just serves the html. However then you lose all the benefits of the Razor templates and intellisense.

C# and .Net 8.0 has a pretty good balance of a nice to work with syntax, a server that provides good performance, and a wide range of supported libraries available. And it is cross platform enough to run on generally any machine you may want to. I have not yet encountered any major issues with compilation times due to improvements made over to the years across ASP.Net Core.

## Why Htmx?

The use of Htmx in this project is partially as a form of research and partially to help cut down on the use of third party dependencies. It minimizes the amount of Javascript involved in the project while leveraging features the browser is good at such as parsing Html. A set of [Htmx Helper Packages](https://github.com/khalidabuhakmeh/Htmx.Net) are also used to make it easier to integrate.

It's perfectly valid and even common to use a framework such as Vue or React to provide the frontend while the server acts as the backend but this involves many tradeoffs. It typically requires a significant amount of model management and screen design that can feel disconnected from the application at times. For this app the tradeoff was made to split most backend processing into the services and let the frontend largely be handled by the controllers / pages acting as a form of glue. This has the benefit of handling a majority of the rendering on the backend and minimizes the amount of issues you can run into from the frontend and backend deviating.

## Why SqlLite?

Sqlite is a database commonly used for smaller applications and portable applications as it stores data in a file on the machine. This has the benefit of not requiring an external server but it does also mean there are some new concerns you need to then deal with such as backups.

Sqlite has been battle tested to handle a significant amount of data if handled and pooled correctly and can often scale up much larger than you might expect. It has been proven to not be a toy database at this point, and the scale of this product is unlikely to hit the limits of the technology.

It is worth noting that due to the [much looser type system Sqlite uses](https://www.sqlite.org/datatype3.html), types would likely need to be slightly refined to move to another database such as postgres. Migrations are typically written to try to use slightly more strict types that Sqlite automatically translates to the types it uses, the types page provides a list of type name conversions for convenience.
